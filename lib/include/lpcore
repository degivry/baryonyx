/* Copyright (C) 2017 INRA
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef ORG_VLEPROJECT_LP_LPCORE
#define ORG_VLEPROJECT_LP_LPCORE

#include <algorithm>
#include <chrono>
#include <cstdarg>
#include <cstdio>
#include <limits>
#include <map>
#include <memory>
#include <stdexcept>
#include <string>
#include <tuple>
#include <vector>

#if defined _WIN32 || defined __CYGWIN__
#define LP_HELPER_DLL_IMPORT __declspec(dllimport)
#define LP_HELPER_DLL_EXPORT __declspec(dllexport)
#define LP_HELPER_DLL_LOCAL
#else
#if __GNUC__ >= 4
#define LP_HELPER_DLL_IMPORT __attribute__((visibility("default")))
#define LP_HELPER_DLL_EXPORT __attribute__((visibility("default")))
#define LP_HELPER_DLL_LOCAL __attribute__((visibility("hidden")))
#else
#define LP_HELPER_DLL_IMPORT
#define LP_HELPER_DLL_EXPORT
#define LP_HELPER_DLL_LOCAL
#endif
#endif

#ifdef LP_DLL
#ifdef liblp_EXPORTS
#define LP_API LP_HELPER_DLL_EXPORT
#else
#define LP_API LP_HELPER_DLL_IMPORT
#endif
#define LP_LOCAL LP_HELPER_DLL_LOCAL
#define LP_MODULE LP_HELPER_DLL_EXPORT
#else
#define LP_API
#define LP_LOCAL
#define LP_MODULE LP_HELPER_DLL_EXPORT
#endif

#if defined(__GNUC__)
#define LP_FORMAT(idformat, idarg)                                            \
    __attribute__((format(printf, (idformat), (idarg))))
#else
#define LP_FORMAT(idformat, idarg)
#endif

namespace lp {

/** @c index is used as accessor for all array. */
using index = int;

struct precondition_error : std::logic_error
{
    precondition_error(const char* msg)
      : std::logic_error(msg)
    {
    }
};

struct postcondition_error : std::logic_error
{
    postcondition_error(const char* msg)
      : std::logic_error(msg)
    {
    }
};

struct numeric_cast_error : public std::exception
{
    const char* what() const noexcept override
    {
        return "numeric cast error: loss of range in numeric_cast";
    }
};

template <typename Target, typename Source>
inline bool
is_numeric_castable(Source arg)
{
    static_assert(std::is_integral<Source>::value, "Integer required.");
    static_assert(std::is_integral<Target>::value, "Integer required.");

    using arg_traits = std::numeric_limits<Source>;
    using result_traits = std::numeric_limits<Target>;

    if (result_traits::digits == arg_traits::digits and
        result_traits::is_signed == arg_traits::is_signed)
        return true;

    if (result_traits::digits > arg_traits::digits)
        return result_traits::is_signed or arg >= 0;

    if (arg_traits::is_signed and
        arg < static_cast<Source>(result_traits::min()))
        return false;

    return arg <= static_cast<Source>(result_traits::max());
}

template <typename Target, typename Source>
inline Target
numeric_cast(Source s)
{
    if (not is_numeric_castable<Target>(s))
        throw lp::numeric_cast_error();

    return static_cast<Target>(s);
}

struct file_access_error : std::runtime_error
{
    file_access_error(std::string file, int error)
      : std::runtime_error("file_access_error")
      , m_file(file)
      , m_error(error)
    {
    }

    std::string file() const
    {
        return m_file;
    }

    int error() const
    {
        return m_error;
    }

private:
    std::string m_file;
    int m_error;
};

struct file_format_error : std::runtime_error
{
    enum class tag
    {
        end_of_file,
        unknown,
        already_defined,
        incomplete,
        bad_name,
        bad_operator,
        bad_integer,
        bad_objective_function_type,
        bad_bound,
        bad_function_element,
        bad_constraint
    };

    file_format_error(std::string element, tag failure, int line, int column)
      : std::runtime_error("file_format_error")
      , m_element(std::move(element))
      , m_line(line)
      , m_column(column)
      , m_failure(failure)
    {
    }

    file_format_error(tag failure, int line, int column)
      : std::runtime_error("file_format_error")
      , m_line(line)
      , m_column(column)
      , m_failure(failure)
    {
    }

    std::string element() const
    {
        return m_element;
    }

    int line() const
    {
        return m_line;
    }

    int column() const
    {
        return m_column;
    }

    tag failure() const
    {
        return m_failure;
    }

private:
    std::string m_element;
    int m_line;
    int m_column;
    tag m_failure;
};

struct problem_definition_error : std::runtime_error
{
    enum class tag
    {
        empty_variables,
        empty_objective_function,
        variable_not_used,
        bad_bound,
        multiple_constraint,
    };

    problem_definition_error(std::string element, tag failure)
      : std::runtime_error("problem_definition_error")
      , m_element(element)
      , m_failure(failure)
    {
    }

    std::string element() const
    {
        return m_element;
    }

    tag failure() const
    {
        return m_failure;
    }

private:
    std::string m_element;
    tag m_failure;
};

struct solver_error : std::runtime_error
{
    enum class tag
    {
        no_solver_available,
        unrealisable_constraint,
        not_enough_memory
    };

    solver_error(tag failure)
      : std::runtime_error("solver_error")
      , m_failure(failure)
    {
    }

    tag failure() const
    {
        return m_failure;
    }

private:
    tag m_failure;
};

struct parameter
{
    enum class tag
    {
        integer,
        real,
        string
    };

    parameter()
      : l(0)
      , type(tag::integer)
    {
    }

    explicit parameter(long value_)
      : l(value_)
      , type(tag::integer)
    {
    }

    explicit parameter(double value_)
      : d(value_)
      , type(tag::real)
    {
    }

    explicit parameter(const std::string& value_)
      : s(value_)
      , type(tag::string)
    {
    }

    parameter(const parameter& w)
      : type(w.type)
    {
        switch (w.type) {
        case tag::integer:
            l = w.l;
            break;
        case tag::real:
            d = w.d;
            break;
        case tag::string:
            new (&s) std::string(w.s);
            break;
        }
    }

    parameter(parameter&& w)
      : type(w.type)
    {
        switch (w.type) {
        case tag::integer:
            l = w.l;
            break;
        case tag::real:
            d = w.d;
            break;
        case tag::string:
            new (&s) std::string(w.s);
            break;
        }

        w.type = tag::integer;
        w.l = 0;
    }

    parameter& operator=(const parameter& w)
    {
        if (type == tag::string and w.type == tag::string) {
            s = w.s;
            return *this;
        }

        if (type == tag::string) {
            using std::string;
            s.~string();
        }

        switch (w.type) {
        case tag::integer:
            l = w.l;
            break;
        case tag::real:
            d = w.d;
            break;
        case tag::string:
            new (&s) std::string(w.s);
            break;
        }

        type = w.type;
        return *this;
    }

    parameter& operator=(parameter&& w)
    {
        if (type == tag::string and w.type == tag::string) {
            new (&s) std::string(w.s);
            w.type = tag::integer;
            w.l = 0;
            return *this;
        }

        if (type == tag::string) {
            using std::string;
            s.~string();
        }

        switch (w.type) {
        case tag::integer:
            l = w.l;
            break;
        case tag::real:
            d = w.d;
            break;
        case tag::string:
            new (&s) std::string(w.s);
            break;
        }

        type = w.type;

        w.type = tag::integer;
        w.l = 0;

        return *this;
    }

    parameter& operator=(double value)
    {
        if (type == tag::real) {
            d = value;
            return *this;
        }

        if (type == tag::string) {
            using std::string;
            s.~string();
        }

        type = tag::real;
        d = value;

        return *this;
    }

    parameter& operator=(long value)
    {
        if (type == tag::integer) {
            l = value;
            return *this;
        }

        if (type == tag::string) {
            using std::string;
            s.~string();
        }

        type = tag::integer;
        l = value;

        return *this;
    }

    parameter& operator=(const std::string& value)
    {
        if (type == tag::string) {
            s = value;
            return *this;
        }

        if (type == tag::string) {
            using std::string;
            s.~string();
        }

        type = tag::string;
        new (&s) std::string(value);

        return *this;
    }

    ~parameter() noexcept
    {
        if (type == tag::string) {
            using std::string;
            s.~string();
        }
    }

    void swap(parameter& p)
    {
        parameter copy(*this);
        *this = p;
        p = copy;
    }

    union
    {
        long l;
        double d;
        std::string s;
    };

    tag type;
};

/* Default, the logging system is active and the call to the @c log
 * function are send to the logger functor. Define LP_DISABLE_LOGGING as
 * preprocessor value to hide all logging message..
 */
class LP_API context
{
public:
    enum class message_type
    {
        emerg,   ///< system is unusable
        alert,   ///< action must be taken immediately
        crit,    ///< critical conditions
        err,     ///< error conditions
        warning, ///< warning conditions
        notice,  ///< normal, but significant, condition
        info,    ///< informational message
        debug,   ///< debug-level message
    };

    class logger
    {
    public:
        logger() = default;
        virtual ~logger() = default;

        virtual void write(int priority,
                           const char* file,
                           int line,
                           const char* fn,
                           const char* fornmat,
                           va_list args) noexcept = 0;

        virtual void write(context::message_type type,
                           const char* format,
                           va_list args) noexcept = 0;
    };

    context() = default;

    context(const context&) = delete;
    context& operator=(const context&) = delete;

    void set_log_priority(int priority) noexcept;
    int get_log_priority() const noexcept;

    void set_standard_stream_logger() noexcept;
    void set_logger(std::unique_ptr<logger> function) noexcept;

    void info(const char* format, ...) noexcept LP_FORMAT(2, 3);
    void debug(const char* format, ...) noexcept LP_FORMAT(2, 3);
    void warning(const char* format, ...) noexcept LP_FORMAT(2, 3);
    void error(const char* format, ...) noexcept LP_FORMAT(2, 3);

    void log(message_type, const char* format, ...) noexcept LP_FORMAT(3, 4);
    void log(int priority,
             const char* file,
             int line,
             const char* fn,
             const char* format,
             ...) noexcept LP_FORMAT(6, 7);

private:
    int m_log_priority = 7;
    std::unique_ptr<logger> m_logger;
};

enum class variable_type
{
    real,
    binary,
    general
};

enum class objective_function_type
{
    undefined,
    maximize,
    minimize
};

enum class operator_type
{
    undefined,
    equal,
    greater,
    greater_equal,
    less,
    less_equal
};

struct variable_value
{
    int min = { 0 };
    int max = std::numeric_limits<int>::max();
    variable_type type = variable_type::real;
    bool min_equal{ true };
    bool max_equal{ false };
};

struct variables
{
    std::vector<std::string> names;
    std::vector<variable_value> values;

    void clear()
    {
        std::vector<std::string>().swap(names);
        std::vector<variable_value>().swap(values);
    }
};

struct function_element
{
    function_element(int factor_, index variable_index_) noexcept
      : factor(factor_),
        variable_index(variable_index_)
    {
    }

    int factor = { 0 };
    index variable_index{ -1 };
};

struct constraint
{
    std::string label;
    std::vector<function_element> elements;
    double value;
};

struct objective_function
{
    std::vector<function_element> elements;
    int constant = { 0 };

    void clear()
    {
        std::vector<function_element>().swap(elements);
    }
};

struct problem
{
    objective_function objective;
    std::vector<constraint> equal_constraints;
    std::vector<constraint> greater_constraints;
    std::vector<constraint> greater_equal_constraints;
    std::vector<constraint> less_constraints;
    std::vector<constraint> less_equal_constraints;

    variables vars;

    objective_function_type type = { objective_function_type::maximize };

    void clear()
    {
        objective.clear();

        std::vector<constraint>().swap(equal_constraints);
        std::vector<constraint>().swap(greater_constraints);
        std::vector<constraint>().swap(greater_equal_constraints);
        std::vector<constraint>().swap(less_constraints);
        std::vector<constraint>().swap(less_equal_constraints);

        vars.clear();
    }
};

enum class result_status
{
    uninitialized,
    success,
    time_limit_reached,
    kappa_max_reached,
    limit_reached
};

struct result
{
    std::string method;

    std::vector<std::string> variable_name;
    std::vector<int> variable_value;
    double duration = 0.0;
    double value = 0.0;
    index loop = 0;
    index variables = 0;
    index constraints = 0;
    index remaining_constraints = std::numeric_limits<index>::max();

    result_status status = result_status::uninitialized;
};

inline std::tuple<double, double>
compute_min_max_objective_function(const problem& pb) noexcept
{
    std::tuple<double, double> ret{ pb.objective.constant,
                                    pb.objective.constant };

    for (const auto& elem : pb.objective.elements)
        if (elem.factor < 0)
            std::get<0>(ret) += elem.factor;
        else if (elem.factor > 0)
            std::get<1>(ret) += elem.factor;
        else
            std::get<1>(ret) += 1;

    return ret;
}

/**
 * Read a \e lp file from the \e file.
 *
 * \exception lp::file_format_error, lp::file_access_error,
 *  std::system_error.
 */
LP_API
problem make_problem(std::shared_ptr<lp::context> ctx,
                     const std::string& filename);

/**
 * Read a \e lp file from the \e is stream.
 *
 * \exception lp::file_format_error, lp::file_access_error,
 *  std::system_error.
 */
LP_API
problem make_problem(std::shared_ptr<lp::context> ctx, std::istream& is);

/**
 * Write \e lp problem into a stream.
 *
 */
LP_API
std::ostream& operator<<(std::ostream& os, const problem& p);

/**
 * Try to solve or find a feasible solution for the \c lp::problem using
 * with a
 * set of parameters.
 *
 * \param pb Problem definition.
 * \param params Parameters for solver.
 *
 * \exception lp::solver_error
 * \exception lp::problem_definition
 */
LP_API
result solve(std::shared_ptr<lp::context> ctx,
             problem& pb,
             const std::map<std::string, parameter>& params);

/**
 * Try to optimize the \c lp::problem with a set of parameters.
 *
 * @param pb Problem definition.
 * @param params Parameters for the solver.
 *
 * @return A representation of the result.
 *
 * @throw \c lp::solver_error.
 */
LP_API
result optimize(std::shared_ptr<lp::context> ctx,
                problem& pb,
                const std::map<std::string, parameter>& params);

/**
 * Try to solve or find a feasible solution for the \c lp::problem using a
 * set
 * of default parameters.
 *
 * \param pb Problem definition.
 *
 * \exception lp::solver_error
 * \exception lp::problem_definition
 */
LP_API
result solve(std::shared_ptr<lp::context> ctx, problem& pb);

/**
 * Try to optimize the \c lp::problem using a set of default parameters.
 *
 * @param pb Problem definition.
 *
 * @return A representation of the result.
 *
 * @throw \c lp::solver_error.
 */
LP_API
result optimize(problem& pb);

LP_API
bool is_valid_solution(const problem& pb,
                       const std::vector<int>& variable_value);

LP_API
double compute_solution(const problem& pb,
                        const std::vector<int>& variable_value);
}

#endif
